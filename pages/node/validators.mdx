# Validator Operations

This comprehensive guide explains how to operate a Sei validator node. We'll
cover the complete lifecycle of a validator, from initial setup through ongoing
operations and maintenance. Understanding these concepts is crucial for
maintaining a reliable and secure validator operation.

## Understanding Validator Responsibilities

A validator in the Sei network serves several critical functions. As a
validator, you are responsible for:

- Participating in consensus by proposing and validating blocks
- Maintaining high uptime and performance to avoid slashing
- Providing accurate oracle price feeds for asset pricing
- Managing delegator relationships and maintaining transparent operations
- Participating in governance and network upgrades

## Initial Setup

### Key Management

The security of your validator begins with proper key management. Your validator
requires several distinct keys:

```bash
# Validator consensus key - Used for signing blocks
seid tendermint show-validator

# Operator key - Used for managing validator operations
seid keys add operator

# Oracle key - Used for price feed submissions
seid keys add oracle
```

These keys serve different purposes and should be managed with appropriate
security measures. The consensus key, stored in `priv_validator_key.json`, is
particularly critical as it's used to sign blocks.

### Hardware Security Module (HSM) Integration

For production validators, using an HSM is strongly recommended. Here's how to
configure an HSM with your validator:

<details>
<summary>HSM Configuration Steps</summary>

```bash
# Install required libraries
sudo apt-get install opensc pkcs11-utils

# Configure YubiHSM2
yubihsm-connector -d

# Generate key in HSM
yubihsm-shell

# Configure seid to use HSM
tee "$HOME/.sei/config/priv_validator_config.json" << EOF
{
    "chain_id": "sei-chain",
    "key_type": "yubihsm",
    "state_file": "$HOME/.sei/data/priv_validator_state.json",
    "hsm_serial": "YOUR_HSM_SERIAL",
    "hsm_key_id": "YOUR_KEY_ID"
}
EOF
```

</details>

### Validator Registration

Before registering your validator, ensure your node is fully synced with the
network. Then create your validator:

```bash
seid tx staking create-validator \
    --amount=1000000usei \
    --pubkey=$(seid tendermint show-validator) \
    --moniker="choose_moniker" \
    --chain-id=sei-chain \
    --commission-rate="0.10" \
    --commission-max-rate="0.20" \
    --commission-max-change-rate="0.01" \
    --min-self-delegation="1" \
    --gas="auto" \
    --gas-adjustment="1.5" \
    --gas-prices="0.01usei" \
    --from=operator
```

The commission parameters deserve careful consideration:

- `commission-rate`: Your initial commission rate
- `commission-max-rate`: An upper limit that can never be exceeded
- `commission-max-change-rate`: Maximum daily commission change

Below is an expanded explanation of the **Oracle Price Feeder** setup and operations. This covers everything from creating a dedicated price-feeder account, to configuring and running the price feeder, to how it fetches and votes on prices on-chain. This also includes notes on monitoring, recommended best practices, and more in-depth references to the underlying logic.

---

## Overview

Running a price feeder is **required** when your validator is participating in a network that depends on oracle data (e.g. Sei). The price feeder is responsible for:

1. **Fetching real-time exchange rates** for a set of assets from various centralized-exchange (CEX) or aggregator data sources (called "providers").
2. **Aggregating and computing** a time-weighted or volume-weighted average price for each asset pair.
3. **Submitting periodic on-chain votes** (pre-vote and vote messages, handled automatically) following the network’s oracle specifications.

If the feeder does not consistently broadcast valid oracle votes, the validator will be **jailed** by the chain’s oracle module, incurring downtime and potential slashings.

---

## Dedicated Price-Feeder Account

Although you _can_ use your main validator key for both validation and oracle feeding, it’s **highly recommended** that you create a **dedicated** “feeder delegate” account. The primary reasons:

- **Safety**: Reduces risk of accidentally revealing or compromising your validator signing key.
- **Reduced Account Sequence Errors**: The price feeder signs many transactions in rapid intervals, which can conflict with other transactions from your validator account and lead to sequence mismatches.

### Steps

1. **Create a new key** within your keyring:

   ```bash
   seid keys add price-feeder-delegate
   ```

   You can name it whatever you like, e.g. `price-feeder-delegate`. This will prompt you for a password (if using an `os` or `file` keyring), which you can set.

2. **Set that new address as the validator’s “feeder address”:**

   ```bash
   export PRICE_FEEDER_DELEGATE_ADDR=<the address from the step above>

   seid tx oracle set-feeder $PRICE_FEEDER_DELEGATE_ADDR --from <validator-wallet> \
       --fees 2000usei -b block -y --chain-id <chain-id>
   ```

3. **Send a small amount of funds** to that new account so it can pay for fees:

   ```bash
   seid tx bank send <validator-wallet> $PRICE_FEEDER_DELEGATE_ADDR \
       [AMOUNT]usei --fees=2000usei -b block -y
   ```

4. **Export** the keyring password so the price feeder can sign automatically:

   ```bash
   export PRICE_FEEDER_PASS=<enter your keyring password>
   ```

   If you don’t set this variable, the feeder will prompt for a password at startup. For systemd usage, you can place this environment variable in the `[Service]` section (see below).

---

## Installing the Price Feeder

1. **Clone or download** the `sei-chain` repo:

   ```bash
   git clone https://github.com/sei-protocol/sei-chain.git
   cd sei-chain
   ```

2. **Compile and install** the standalone feeder binary:

   ```bash
   make install-price-feeder
   ```

   This produces a `price-feeder` binary typically placed in your `$GOPATH/bin` (for Go-based systems) or `/usr/local/bin`. You can verify it with `which price-feeder`.

---

## Configuration

The price feeder operates off a single `config.toml` file (referred to as `/path/to/price_feeder_config.toml` below). In Sei, this config is heavily influenced by the [Umee Price Feeder](https://github.com/umee-network/umee/tree/main/price-feeder) but adapted for Sei’s `oracle` module. A sample `config.toml` might look like:

<details>
<summary>Price Feeder Configuration</summary>

```toml
gas_adjustment = 1.5
gas_prices = "0.00125usei"
enable_server = true
enable_voter = true

[server]
listen_addr = "0.0.0.0:7171"
read_timeout = "20s"
verbose_cors = true
write_timeout = "20s"

[[deviation_thresholds]]
base = "ETH"
threshold = "2"

# (You can repeat the same block for BTC, USDC, SEI, etc.)

[[currency_pairs]]
base = "ETH"
chain_denom = "ueth"
providers = ["huobi", "crypto", "coinbase", "kraken", "okx"]
quote = "USDT"

# (Currency pairs for BTC, USDC, ATOM, etc...)

[account]
address = "FEEDER_ADDR"   # e.g. $PRICE_FEEDER_DELEGATE_ADDR
chain_id = "CHAIN_ID"     # e.g. sei-testnet-2 or sei-mainnet-xyz
validator = "VALIDATOR_ADDR" # e.g. seivaloper1...
prefix = "sei"

[keyring]
backend = "os"
dir = "/root/.sei"

[rpc]
grpc_endpoint = "localhost:9090"
rpc_timeout = "100ms"
tmrpc_endpoint = "http://localhost:26657"

[telemetry]
enable_hostname = true
enable_hostname_label = true
enable_service_label = true
enabled = true
global_labels = [["chain_id", "sei-chain"]]
service_name = "price-feeder"
prometheus_retention = 60

[[provider_endpoints]]
name = "binance"
rest = "https://api1.binance.com"
websocket = "stream.binance.com:9443"

[[healthchecks]]
url = "https://hc-ping.com/your-uuid"
timeout = "5s"
```

</details>

### Key Sections

1. **`[account]`**

   - `address` corresponds to the feeder account’s Bech32 address, i.e. `$PRICE_FEEDER_DELEGATE_ADDR`.
   - `chain_id` is the chain ID of the network you’re using (must match your `seid` config).
   - `validator` is the **operator address** of your validator, e.g. `seivaloper1xyz...`.
   - `prefix` sets the human-readable prefix for addresses (“sei”). This is needed so the code knows how to encode/decode Bech32 addresses for your network.

2. **`[keyring]`**

   - `backend` is typically “os”, “file”, “test”, “memory”, etc. If you used `seid keys add ...` in typical production mode, you likely have an `os` or `file` backend.
   - `dir` points to the location of `.sei/keys` or wherever your keys are stored. This is typically `~/.sei` or `/root/.sei`.

3. **`[rpc]`**

   - `tmrpc_endpoint` points to your node’s RPC address, typically `http://localhost:26657`.
   - `grpc_endpoint` points to your node’s GRPC address, typically `localhost:9090`.
   - `rpc_timeout` is how long the feeder waits for an RPC response before timing out.

4. **`[server]`** (optional if `enable_server = true`)

   - `listen_addr` sets the local interface/port for the feeder’s **health** and **metrics** API endpoint (default `0.0.0.0:7171`).
   - `write_timeout` and `read_timeout` set how long the feeder’s HTTP server will wait before timing out.

5. **`[[currency_pairs]]`**

   - Each block indicates a `base` (e.g. `ETH`) and a `quote` (e.g. `USDT`) pair, plus the **chain denoms** and **providers** used to fetch prices for that pair.
   - The `chain_denom` is the way the on-chain oracle recognizes your base. For instance, if the chain internally uses `ueth` for Ether.
   - **Providers** must be supported (Binance, Kraken, Crypto, etc.). If you list multiple providers, the feeder tries to fetch from each and then does time-/volume-weighted averaging, ignoring outliers that deviate too far from the mean.

6. **`[[deviation_thresholds]]`**

   - For each `base` (like “ETH”), you can set a tolerance threshold that helps the feeder ignore obviously incorrect data from any single provider. E.g. `threshold = "2"` means that if a provider’s price is 2 standard deviations away from the aggregated median, that data point is filtered.

7. **Healthchecks** (optional)
   - If you define a `[healthchecks]` block with a URL, the feeder will `GET` that endpoint each time it broadcasts a successful price vote. Helpful for pinging third-party services like [healthchecks.io](https://healthchecks.io) to alert you if the feeder fails.

---

## Running as a Systemd Service

Running the price feeder under **systemd** is a best practice for servers, ensuring it auto-starts on reboot and restarts if it crashes. Below is a typical unit file at `/etc/systemd/system/price-feeder.service`:

```ini
[Unit]
Description=Sei Price Feeder
After=network-online.target

[Service]
User=root
Type=simple
# Pass your keyring password
Environment="PRICE_FEEDER_PASS=YOUR_KEYRING_PASSWORD"
ExecStart=/usr/local/bin/price-feeder /root/price_feeder_config.toml
Restart=on-failure
RestartSec=3
LimitNOFILE=6553500

[Install]
WantedBy=multi-user.target
EOF
```

Refresh and start the service, and watch initial logs for any issues:

```sh
sudo systemctl daemon-reload
sudo systemctl enable price-feeder
sudo systemctl start price-feeder && journalctl -fu price-feeder -o cat
```

---

## High-level breakdown of the feeder process:

1. **Initialization**:

   - Reads your `config.toml`.
   - Sets up the keyring with your feeder account.
   - Connects to your node's RPC and gRPC.

2. **Price Gathering**:

   - For each configured `provider` (Binance, Kraken, etc.), queries the _latest market data_ (candles, tickers).
   - Cleans and discards outlier data if it is more than `N` standard deviations away from the median (defined by `[[deviation_thresholds]]`).
   - Aggregates each data point into a final volume- or time-weighted price.

3. **Voting**:

   - Checks the on-chain `oracleParams.VotePeriod` to see when it’s time to broadcast a new vote.
   - Constructs a `MsgAggregateExchangeRateVote` message listing all the `[base -> chain_denom]` pairs with their computed prices.
   - Signs and broadcasts the transaction via the gRPC and RPC endpoints.
   - If multiple currencies share the same `quote`, the feeder automatically converts them to the standard the oracle module expects (usually USD or USDT).

4. **Healthchecks** (optional):

   - After each successful vote, the feeder can ping a user-defined `healthchecks` endpoint, letting external services know it’s live and functioning.

5. **Telemetry & API** (if `enable_server = true`):
   - Exposes Prometheus-compatible metrics at `/metrics` on the `listen_addr`.
   - Exposes JSON endpoints for health (`/healthz`) and the current computed prices (`/prices`).

If the price feeder does not send any votes for an extended period, the on-chain module will detect missing votes and jail your validator.

---

## Monitoring & Alerting

### Built-In Telemetry

If `[telemetry]` is enabled in `config.toml`, the price feeder exposes internal metrics (e.g. how long it took to fetch data, last block voted on, errors, etc.):

- **Endpoint**: `<listen_addr>/api/v1/metrics` (e.g. `http://127.0.0.1:7171/api/v1/metrics`)
- **Format**: By default, Prometheus text format. You can pass `?format=json` to get JSON metrics.

### Price Feeder Health

- **Health** endpoint: `<listen_addr>/api/v1/healthz` returns a simple JSON with `"Status":"available"` if running.

### On-Chain Checks

Aside from direct logs and systemd status, you can also:

```bash
# Check your validator’s on-chain status
seid query staking validator $(seid keys show -a <validator-key>)
```

If your validator becomes jailed, you will no longer be signing blocks or generating rewards or commission. You can check the status in the staking module"

```sh
curl -s "http://localhost:1317/cosmos/staking/v1beta1/validators/
```

### Example Prometheus Rules

For a more robust setup, integrate the node’s and feeder’s metrics with a Prometheus + Grafana stack. Set rules like:

```yaml
groups:
  - name: validator_alerts
    rules:
      - alert: ValidatorMissedBlocks
        expr: increase(tendermint_consensus_validator_missed_blocks[1h]) > 0
        labels:
          severity: critical
        annotations:
          summary: 'Validator missing blocks'

      - alert: ValidatorJailed
        expr: tendermint_consensus_validator_status == 0
        labels:
          severity: critical
        annotations:
          summary: 'Validator has been jailed'

      - alert: OraclePriceFeedDelay
        expr: time() - sei_oracle_price_timestamp > 300
        labels:
          severity: critical
        annotations:
          summary: 'Oracle price feed delayed'
```

This should ensure you are alerted if the oracle feeder stops updating, or worse.

---

## Best Practices & Tips

- **Use Multiple Providers**: For each base asset, specify at least three different data providers. Price feeders try to ignore outliers. The more providers you have, the more resilient your feed is.
- **Separate Feeder Account**: Always use a dedicated account for feeding to reduce the chance of sequence collisions and keep your validator key safe.
- **Keep Service & Node on Same Host**: Minimize latency by running the feeder on the same machine as the node it queries (or a local network if that is not possible).
- **Enable Telemetry & Alerting**: Integrate your metrics into Prometheus or a similar system. Oracle feed downtime is a critical event.

## Final Checklist

1. **Create & Fund Delegate Feeder Account**
2. **Set Feeder Address** on-chain to your newly created delegate
3. **Install** the `price-feeder` binary
4. **Write** your `config.toml` with correct accounts, pairs, RPC endpoints, and providers
5. **Configure** systemd (or your preferred process manager)
6. **Enable Telemetry & Alerting** with your favorite stack
7. **Monitor** logs, ensure votes are being broadcast every oracle vote period

If set up correctly, your validator will remain healthy and will continually submit price votes, thus contributing to the on-chain oracle’s price data and staying out of jail.

## Security Practices

### Network Security

Implement a sentry node architecture to protect your validator:

```bash
# Validator node config.toml
[p2p]
pex = false
persistent_peers = "sentry_node_id@sentry_node_ip:26656"
private_peer_ids = ""
addr_book_strict = false

# Sentry node config.toml
[p2p]
pex = true
private_peer_ids = "validator_node_id"
addr_book_strict = true
```

### Key Management Practices

Implement secure key backup procedures:

<details>
<summary>Key Backup Script</summary>

```bash
#!/bin/bash
# Create encrypted backup of validator keys
BACKUP_DIR="/secure/validator/backup"
DATE=$(date +%Y%m%d)

# Backup validator key
tar czf - $HOME/.sei/config/priv_validator_key.json | \
    gpg --symmetric --cipher-algo AES256 \
    -o $BACKUP_DIR/validator_key_$DATE.tar.gz.gpg

# Backup keyring
tar czf - $HOME/.sei/keyring-file | \
    gpg --symmetric --cipher-algo AES256 \
    -o $BACKUP_DIR/keyring_$DATE.tar.gz.gpg

# Create SHA256 checksums
sha256sum $BACKUP_DIR/*.gpg > $BACKUP_DIR/checksums_$DATE.txt
```

</details>

## Maintenance Procedures

### Planned Maintenance

When performing planned maintenance:

```bash
# Notify delegators (recommended at least 24h in advance)
# Consider posting to:
# - Chain governance forum
# - Social media channels
# - Validator website

# Gracefully stop the validator
sudo systemctl stop seid

# Perform maintenance tasks

# Restart services
sudo systemctl start seid
sudo systemctl start price-feeder
```

### Emergency Procedures

Create an emergency response plan:

<details>
<summary>Emergency Response Procedures</summary>

```bash
# 1. If double-signing is detected:
sudo systemctl stop seid
# Investigate priv_validator_state.json
# Contact team and delegators

# 2. If node is stuck:
seid status
# Check for consensus failures
journalctl -u seid -n 100
# Attempt safe restart
sudo systemctl restart seid

# 3. If oracle feed fails:
systemctl status price-feeder
# Check price-feeder logs
journalctl -u price-feeder -n 100
# Restart if necessary
sudo systemctl restart price-feeder
```

</details>

## Governance Participation

As a validator, you have a responsibility to participate in governance. Monitor
and vote on proposals:

```bash
# List active proposals
seid query gov proposals --status voting_period

# Vote on a proposal
seid tx gov vote 1 yes \
    --from operator \
    --chain-id sei-chain \
    --gas auto \
    --gas-prices 0.01usei
```

## Validator Economics

Understanding validator economics is crucial for long-term success:

- Commission Rate Strategy: Set competitive rates while ensuring operational
  sustainability
- Delegation Management: Maintain good delegator relationships through
  transparent communication
- Reward Distribution: Rewards are distributed in real-time as blocks are
  produced
- Slashing Risks: Understand and mitigate risks of slashing through proper
  operation

## Recovery Procedures

### Validator Recovery

If you need to recover your validator on a new machine:

```bash
# 1. Set up new machine with Sei node
# 2. Copy secured backup files
# 3. Restore validator key
gpg -d validator_key_backup.tar.gz.gpg | tar xzf -
# 4. Restore keyring
gpg -d keyring_backup.tar.gz.gpg | tar xzf -
# 5. Start services
sudo systemctl start seid
sudo systemctl start price-feeder
```

This guide provides a foundation for operating a Sei validator. Remember that
validator operation requires constant attention to security, performance, and
network participation. Stay engaged with the Sei community and keep updated with
network developments.
