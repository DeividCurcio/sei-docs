---
title: "Build on Sei Giga"
description: "Practical patterns and examples for building high-performance applications on Sei"
keywords: ["sei development", "parallel execution", "optimization patterns", "dapp development"]
---

import { Callout } from 'nextra/components';

# Building on Sei: Developer Patterns

This guide focuses on practical patterns for maximizing performance when building on Sei.

## Designing for Parallel Execution

Consider a typical DeFi scenario with multiple users:

```solidity
// Traditional sequential processing:
// User A swaps USDC for ETH (100ms)
// User B stakes SEI (100ms)  
// User C mints NFT (100ms)
// Total time: 300ms

// Sei's parallel processing:
// All three execute simultaneously
// Total time: 100ms
```

The key: transactions touching different state execute in parallel.

### State Isolation Pattern

```solidity copy filename="contracts/ParallelFriendlyDEX.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract ParallelFriendlyDEX {
    // GOOD: State isolated by user
    mapping(address => uint256) private balances;
    mapping(address => mapping(address => uint256)) private allowances;
    
    // Each user's operations are independent
    function deposit() external payable {
        balances[msg.sender] += msg.value;
    }
    
    // BAD: Global state creates conflicts
    uint256 public totalDeposits; // Every deposit must update this
    
    function depositWithGlobalCounter() external payable {
        balances[msg.sender] += msg.value;
        totalDeposits += msg.value; // Forces sequential execution
    }
}
```

## Precompile Integration Examples

### Oracle Integration Pattern

```solidity copy filename="contracts/OracleAMM.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IOracle {
    struct OracleExchangeRate {
        string exchangeRate;
        string lastUpdate;
        int64 lastUpdateTimestamp;
    }
    
    struct DenomOracleExchangeRatePair {
        string denom;
        OracleExchangeRate oracleExchangeRateVal;
    }
    
    function getExchangeRates() external view returns (DenomOracleExchangeRatePair[] memory);
}

contract OracleAMM {
    IOracle constant oracle = IOracle(0x0000000000000000000000000000000000001008);
    
    uint256 constant PRICE_STALENESS_THRESHOLD = 60; // 60 seconds
    
    modifier withFreshPrice(string memory denom) {
        (,int64 timestamp) = getOraclePrice(denom);
        require(block.timestamp - uint256(uint64(timestamp)) < PRICE_STALENESS_THRESHOLD, "Stale price");
        _;
    }
    
    function getOraclePrice(string memory denom) public view returns (string memory price, int64 timestamp) {
        IOracle.DenomOracleExchangeRatePair[] memory rates = oracle.getExchangeRates();
        
        for (uint256 i = 0; i < rates.length; i++) {
            if (keccak256(bytes(rates[i].denom)) == keccak256(bytes(denom))) {
                return (
                    rates[i].oracleExchangeRateVal.exchangeRate,
                    rates[i].oracleExchangeRateVal.lastUpdateTimestamp
                );
            }
        }
        revert("Price not found");
    }
    
    function swapWithOracleProtection(
        string memory tokenIn,
        string memory tokenOut,
        uint256 amountIn
    ) external withFreshPrice(tokenIn) withFreshPrice(tokenOut) {
        // Swap logic using oracle prices for slippage protection
    }
}
```

### Native Token Bridge Pattern

With SIP-3, cross-chain functionality will rely on EVM-style bridges:

```solidity copy filename="contracts/EVMBridge.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IERC20 {
    function transferFrom(address from, address to, uint256 amount) external returns (bool);
    function mint(address to, uint256 amount) external;
    function burn(uint256 amount) external;
}

contract EVMBridge {
    mapping(bytes32 => bool) public processedTransfers;
    mapping(address => bool) public supportedTokens;
    
    event TokensLocked(address indexed token, address indexed from, bytes32 indexed transferId, uint256 amount);
    event TokensReleased(address indexed token, address indexed to, bytes32 indexed transferId, uint256 amount);
    
    function lockTokens(address token, uint256 amount, bytes32 transferId) external {
        require(supportedTokens[token], "Token not supported");
        require(!processedTransfers[transferId], "Transfer already processed");
        
        processedTransfers[transferId] = true;
        IERC20(token).transferFrom(msg.sender, address(this), amount);
        
        emit TokensLocked(token, msg.sender, transferId, amount);
    }
    
    // Called by bridge validators/relayers
    function releaseTokens(
        address token,
        address recipient,
        uint256 amount,
        bytes32 transferId,
        bytes calldata signature
    ) external {
        require(supportedTokens[token], "Token not supported");
        require(!processedTransfers[transferId], "Transfer already processed");
        require(verifySignature(token, recipient, amount, transferId, signature), "Invalid signature");
        
        processedTransfers[transferId] = true;
        IERC20(token).mint(recipient, amount);
        
        emit TokensReleased(token, recipient, transferId, amount);
    }
    
    function verifySignature(
        address token,
        address recipient,
        uint256 amount,
        bytes32 transferId,
        bytes calldata signature
    ) internal pure returns (bool) {
        // Implement signature verification logic
        return true; // Placeholder
    }
}
```

### Liquid Staking Integration

<Callout type="info">
Staking precompiles will continue to function in the EVM-only architecture, allowing liquid staking protocols to operate.
</Callout>

```solidity copy filename="contracts/LiquidStaking.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

interface IStaking {
    function delegate(string memory valAddress) payable external returns (bool);
    function undelegate(string memory valAddress, uint256 amount) external returns (bool);
}

interface IBank {
    function balance(address acc, string memory denom) external view returns (uint256);
}

contract LiquidStaking {
    IStaking constant staking = IStaking(0x0000000000000000000000000000000000001005);
    IBank constant bank = IBank(0x0000000000000000000000000000000000001001);
    
    mapping(address => uint256) public shares;
    uint256 public totalShares;
    string public validatorAddress;
    
    constructor(string memory _validator) {
        validatorAddress = _validator;
    }
    
    function stake() external payable {
        require(msg.value > 0, "No SEI sent");
        
        uint256 shareAmount = msg.value;
        if (totalShares > 0) {
            uint256 totalStaked = bank.balance(address(this), "usei");
            shareAmount = (msg.value * totalShares) / totalStaked;
        }
        
        shares[msg.sender] += shareAmount;
        totalShares += shareAmount;
        
        bool success = staking.delegate{value: msg.value}(validatorAddress);
        require(success, "Delegation failed");
    }
}
```

## Optimization Patterns

### Batch Processing

```solidity copy filename="contracts/BatchProcessor.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract BatchProcessor {
    struct Transfer {
        address to;
        uint256 amount;
    }
    
    mapping(address => uint256) private balances;
    
    // Process multiple operations atomically
    function batchTransfer(Transfer[] calldata transfers) external {
        uint256 totalAmount = 0;
        
        // First pass: calculate total
        for (uint256 i = 0; i < transfers.length; i++) {
            totalAmount += transfers[i].amount;
        }
        
        // Single balance check
        require(balances[msg.sender] >= totalAmount, "Insufficient balance");
        balances[msg.sender] -= totalAmount;
        
        // Second pass: distribute (parallel-friendly)
        for (uint256 i = 0; i < transfers.length; i++) {
            balances[transfers[i].to] += transfers[i].amount;
        }
    }
}
```

### Storage Packing

```solidity copy filename="contracts/StoragePacking.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract StorageEfficient {
    // BAD: Uses 3 storage slots
    struct PoorlyPacked {
        uint256 amount;     // Slot 1
        address user;       // Slot 2
        uint256 timestamp;  // Slot 3
    }
    
    // GOOD: Uses 2 storage slots
    struct WellPacked {
        uint256 amount;     // Slot 1
        address user;       // Slot 2 (160 bits)
        uint96 timestamp;   // Slot 2 (96 bits) - fits with address
    }
    
    // BEST: Uses 1 storage slot for common operations
    struct OptimalPacked {
        uint128 amount;     // 128 bits
        uint64 timestamp;   // 64 bits
        uint64 nonce;       // 64 bits
        // Total: 256 bits = 1 slot
    }
}
```

### Event-Driven Architecture

```solidity copy filename="contracts/EventDriven.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract EventDrivenAuction {
    struct Auction {
        uint128 highestBid;
        address highestBidder;
        uint64 endTime;
    }
    
    mapping(uint256 => Auction) public auctions;
    
    // Store bid history in events, not storage
    event BidPlaced(uint256 indexed auctionId, address indexed bidder, uint256 amount);
    event AuctionWon(uint256 indexed auctionId, address indexed winner, uint256 amount);
    
    function bid(uint256 auctionId) external payable {
        Auction storage auction = auctions[auctionId];
        require(block.timestamp < auction.endTime, "Auction ended");
        require(msg.value > auction.highestBid, "Bid too low");
        
        // Refund previous bidder
        if (auction.highestBidder != address(0)) {
            payable(auction.highestBidder).transfer(auction.highestBid);
        }
        
        auction.highestBid = uint128(msg.value);
        auction.highestBidder = msg.sender;
        
        // Emit event instead of storing bid history
        emit BidPlaced(auctionId, msg.sender, msg.value);
    }
}
```

## Common Pitfalls & Solutions

### Avoiding Sequential Bottlenecks

```solidity copy filename="contracts/AvoidBottlenecks.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract AvoidBottlenecks {
    // BAD: Global nonce forces sequential execution
    uint256 public globalNonce;
    mapping(uint256 => address) public nonceToUser;
    
    function badMint() external {
        uint256 tokenId = globalNonce++;
        nonceToUser[tokenId] = msg.sender;
    }
    
    // GOOD: User-specific nonces allow parallelism
    mapping(address => uint256) public userNonces;
    mapping(address => mapping(uint256 => uint256)) public userTokens;
    
    function goodMint() external {
        uint256 userNonce = userNonces[msg.sender]++;
        userTokens[msg.sender][userNonce] = block.timestamp;
    }
}
```

### Optimistic Execution

```solidity copy filename="contracts/OptimisticExecution.sol"
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract OptimisticVault {
    mapping(address => uint256) public balances;
    uint256 public totalSupply;
    
    // Optimistic deposit - assumes success
    function deposit(uint256 amount) external returns (uint256 shares) {
        // Calculate shares optimistically
        if (totalSupply == 0) {
            shares = amount;
        } else {
            shares = (amount * totalSupply) / address(this).balance;
        }
        
        // Update state
        balances[msg.sender] += shares;
        totalSupply += shares;
        
        // Transfer happens last - if it fails, entire tx reverts
        (bool success,) = address(this).call{value: amount}("");
        require(success, "Transfer failed");
    }
}
```

## Quick Reference

### Gas Optimization Checklist
- ✓ Pack structs to minimize storage slots
- ✓ Use events for historical data
- ✓ Cache array lengths in loops
- ✓ Use `unchecked` blocks where safe
- ✓ Batch operations when possible
- ✓ Minimize external calls

### Parallel Execution Checklist
- ✓ Isolate state by user/entity
- ✓ Avoid global counters
- ✓ Use mapping over arrays for lookups
- ✓ Design for optimistic execution
- ✓ Minimize shared state dependencies

### Security Considerations
- ✓ Follow checks-effects-interactions pattern
- ✓ Use custom errors for gas efficiency
- ✓ Implement proper access controls
- ✓ Handle all return values
- ✓ Consider reentrancy guards where needed

## Next Steps

- Review [precompile documentation](/evm/precompiles) for detailed interfaces
- Explore [EVM development guide](/evm) for setup instructions
- Join the [Sei Discord](https://discord.gg/sei) for developer support
